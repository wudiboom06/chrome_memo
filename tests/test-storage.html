<!-- tests/test-storage.html：基于 mock 的 storage 封装单元测试，浏览器直开或本地服务器均可 -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>storage 封装单元测试</title>
  <style>
    body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding: 16px; }
    .pass { color: #0a7a0a; }
    .fail { color: #b00020; }
    .item { margin: 8px 0; }
  </style>
</head>
<body>
  <h1>storage 封装单元测试</h1>
  <div id="log"></div>

  <script type="module">
    // 先注入 mock 的 chrome.storage.local，确保在导入被测模块前完成
    const _store = {};
    window.chrome = {
      storage: {
        local: {
          get(keys, cb) {
            const result = {};
            if (typeof keys === 'string') {
              result[keys] = _store[keys];
            } else if (Array.isArray(keys)) {
              keys.forEach(k => { result[k] = _store[k]; });
            } else if (keys && typeof keys === 'object') {
              Object.assign(result, keys);
              for (const k in _store) result[k] = _store[k];
            }
            setTimeout(() => cb(result), 0);
          },
          set(items, cb) {
            Object.assign(_store, items);
            setTimeout(() => cb && cb(), 0);
          },
          remove(keys, cb) {
            const arr = Array.isArray(keys) ? keys : [keys];
            arr.forEach(k => { delete _store[k]; });
            setTimeout(() => cb && cb(), 0);
          }
        }
      },
      runtime: {}
    };

    // 延后导入，被测模块会读取上面注入的 mock
    const storageMod = await import('../lib/storage.js');
    const idMod = await import('../lib/id.js');

    // 简单断言与日志输出
    const $log = document.getElementById('log');
    function assert(desc, condition) {
      const div = document.createElement('div');
      div.className = 'item ' + (condition ? 'pass' : 'fail');
      div.textContent = (condition ? '✔︎ 通过：' : '✘ 失败：') + desc;
      $log.appendChild(div);
      if (!condition) console.error('断言失败：' + desc);
    }

    // 用例 1：初始读取应为空数组
    {
      const list = await storageMod.getNotes();
      assert('初始应为空数组', Array.isArray(list) && list.length === 0);
    }

    // 用例 2：新增两条，检查数量、排序与默认完成状态
    let id1 = idMod.generateId();
    let now = Date.now();
    await storageMod.addNote({
      id: id1, content: 'hello', createdAt: now, updatedAt: now, done: false
    });
    let id2 = idMod.generateId();
    now += 5;
    await storageMod.addNote({
      id: id2, content: 'world', createdAt: now, updatedAt: now, done: false
    });
    {
      const list = await storageMod.getNotes();
      assert('新增后数量为 2', list.length === 2);
      assert('新增项未完成', list.every(n => n.done === false));
      assert('排序应为第二条在前', list[0].id === id2);
    }

    // 用例 3：设置第一条为完成，验证排序与完成状态
    {
      const updated = await storageMod.setNoteDone(id1, true);
      assert('设置完成返回 done=true', updated.done === true);
      const list = await storageMod.getNotes();
      assert('完成的放在列表底部', list[list.length - 1].id === id1);
      assert('未完成的仍在顶部', list[0].done === false);
    }

    // 用例 4：更新已完成项内容，仍应留在底部
    {
      await storageMod.updateNote(id1, 'hello-updated');
      const list = await storageMod.getNotes();
      assert('完成项仍在底部', list[list.length - 1].id === id1);
      assert('内容已更新', list[list.length - 1].content === 'hello-updated');
      assert('完成标记仍为 true', list[list.length - 1].done === true);
    }

    // 用例 5：恢复为未完成，排序回到顶部
    {
      const updated = await storageMod.setNoteDone(id1, false);
      assert('恢复后 done=false', updated.done === false);
      const list = await storageMod.getNotes();
      assert('恢复未完成后回到顶部', list[0].id === id1);
    }

    // 用例 6：删除并验证数量变化与返回值
    {
      const ok = await storageMod.deleteNote(id2);
      const list = await storageMod.getNotes();
      assert('删除返回 true', ok === true);
      assert('删除后数量为 1', list.length === 1);
      assert('剩余的应为 ID1', list[0].id === id1);
    }

    // 用例 7：异常路径校验（示例：空内容更新）
    try {
      await storageMod.updateNote(id1, '   ');
      assert('空内容更新应抛错', false);
    } catch (e) {
      assert('空内容更新已抛错', /不能为空/.test(String(e?.message)));
    }
  </script>
</body>
</html>
