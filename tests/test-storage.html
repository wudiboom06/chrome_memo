<!-- tests/test-storage.html：基于 mock 的 storage 单元测试，浏览器直开或本地服务器均可 -->
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <title>storage 封装单元测试</title>
  <style>
    body { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; padding: 16px; }
    .pass { color: #0a7a0a; }
    .fail { color: #b00020; }
    .item { margin: 8px 0; }
  </style>
</head>
<body>
  <h1>storage 封装单元测试</h1>
  <div id="log"></div>

  <script type="module">
    // 先注入 mock 的 chrome.storage.local，确保在导入被测模块前完成
    const _store = {};                                               // 内存键值存储
    window.chrome = {
      storage: {
        local: {
          // 兼容 string / string[] / {key: default} 三种调用形态
          get(keys, cb) {
            const result = {};
            if (typeof keys === 'string') {
              result[keys] = _store[keys];
            } else if (Array.isArray(keys)) {
              keys.forEach(k => { result[k] = _store[k]; });
            } else if (keys && typeof keys === 'object') {
              Object.assign(result, keys);                            // 先填充默认值
              for (const k in _store) result[k] = _store[k];         // 再覆盖已有值
            }
            setTimeout(() => cb(result), 0);                         // 异步回调
          },
          set(items, cb) {
            Object.assign(_store, items);                            // 写入或覆盖
            setTimeout(() => cb && cb(), 0);                         // 异步回调
          },
          remove(keys, cb) {
            const arr = Array.isArray(keys) ? keys : [keys];         // 规范为数组
            arr.forEach(k => { delete _store[k]; });                 // 删除键
            setTimeout(() => cb && cb(), 0);                         // 异步回调
          }
        }
      },
      runtime: {}                                                    // 仅为兼容 lastError 访问
    };

    // 延后导入，被测模块会读取上面注入的 mock
    const storageMod = await import('../lib/storage.js');            // 导入被测模块
    const idMod = await import('../lib/id.js');                      // 导入 ID 生成器

    // 简单断言与日志输出
    const $log = document.getElementById('log');
    function assert(desc, condition) {
      const div = document.createElement('div');
      div.className = 'item ' + (condition ? 'pass' : 'fail');
      div.textContent = (condition ? '✔︎ 通过：' : '✘ 失败：') + desc;
      $log.appendChild(div);
      if (!condition) console.error('断言失败：' + desc);
    }

    // 用例 1：初始读取应为空数组
    {
      const list = await storageMod.getNotes();                      // 调用被测函数
      assert('初始应为空数组', Array.isArray(list) && list.length === 0); // 断言为空
    }

    // 用例 2：新增两条，检查数量与排序（按 updatedAt 倒序）
    let id1 = idMod.generateId();                                    // 生成 ID1
    let now = Date.now();                                            // 当前时间戳
    await storageMod.addNote({                                       // 新增第一条
      id: id1, content: 'hello', createdAt: now, updatedAt: now
    });
    let id2 = idMod.generateId();                                    // 生成 ID2
    now += 5;                                                        // 确保更晚的时间
    await storageMod.addNote({                                       // 新增第二条
      id: id2, content: 'world', createdAt: now, updatedAt: now
    });
    {
      const list = await storageMod.getNotes();                      // 读取
      assert('新增后数量为 2', list.length === 2);                    // 数量 = 2
      assert('排序应为第二条在前', list[0].id === id2);               // 新的在前
    }

    // 用例 3：更新第一条的内容，并验证被移动到顶部且内容变更
    {
      await storageMod.updateNote(id1, 'hello-updated');             // 更新 ID1
      const list = await storageMod.getNotes();                      // 读取
      assert('更新后移动到顶部', list[0].id === id1);                 // 顶部应为 ID1
      assert('更新后内容已变更', list[0].content === 'hello-updated'); // 内容更新
    }

    // 用例 4：删除并验证数量变化与返回值
    {
      const ok = await storageMod.deleteNote(id2);                   // 删除 ID2
      const list = await storageMod.getNotes();                      // 读取
      assert('删除返回 true', ok === true);                           // 返回 true
      assert('删除后数量为 1', list.length === 1);                     // 剩 1 条
      assert('剩余的应是 ID1', list[0].id === id1);                   // 剩余为 ID1
    }

    // 用例 5：异常路径校验（示例：空内容更新）
    try {
      await storageMod.updateNote(id1, '   ');                       // 试图更新为空
      assert('空内容更新应抛错', false);                              // 不应走到这里
    } catch (e) {
      assert('空内容更新已抛错', /不能为空/.test(String(e?.message)));   // 捕获到错误
    }
  </script>
</body>
</html>
